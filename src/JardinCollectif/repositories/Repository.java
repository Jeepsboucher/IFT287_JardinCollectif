package JardinCollectif.repositories;

import JardinCollectif.IFT287Exception;
import JardinCollectif.annotations.Initializer;
import JardinCollectif.repositories.helpers.ColumnHelper;
import JardinCollectif.repositories.helpers.GenericHelper;
import JardinCollectif.repositories.helpers.TableHelper;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public abstract class Repository<T> extends GenericHelper<T> {
  private final PreparedStatement createStatement;
  private final PreparedStatement retrieveStatement;
  private final PreparedStatement retrieveAllStatement;
  private final PreparedStatement updateStatement;
  private final PreparedStatement deleteStatement;
  private final PreparedStatement existsStatement;
  private final TableHelper tableHelper;

  public Repository(Connection connection) throws SQLException, ClassNotFoundException, IFT287Exception {
    tableHelper = new TableHelper(getGenericType());

    String tableName = tableHelper.getTableName();
    String primaryKeyName = tableHelper.getPrimaryKey().stream().map(column -> column.getName())
            .collect(Collectors.joining("=? AND ", "", "=?"));

    List<ColumnHelper> columnsWithoutAutogenerated = tableHelper.getColumns().stream()
            .filter(columnHelper -> !columnHelper.isAutoGenerated()).collect(Collectors.toList());
    String createColumnsNames = columnsWithoutAutogenerated.stream().map(column -> column.getName())
            .collect(Collectors.joining(","));
    String createValues = IntStream.range(0, columnsWithoutAutogenerated.size()).mapToObj(i -> "?")
            .collect(Collectors.joining(","));

    String columnsNames = tableHelper.getColumns().stream().map(column -> column.getName())
            .collect(Collectors.joining(","));
    String setValues = tableHelper.getColumns().stream().filter(columnHelper -> !columnHelper.isPrimary())
            .map(column -> column.getName()).collect(Collectors.joining("=?,", "", "=?"));

    createStatement = connection
            .prepareStatement("INSERT INTO " + tableName + "(" + createColumnsNames + ") VALUES (" + createValues + ");");
    retrieveStatement = connection
            .prepareStatement("SELECT " + columnsNames + " FROM " + tableName + " WHERE " + primaryKeyName + ";");
    retrieveAllStatement = connection
            .prepareStatement("SELECT " + columnsNames + " FROM " + tableName + ";");
    updateStatement = connection
            .prepareStatement("UPDATE " + tableName + " SET " + setValues + " WHERE " + primaryKeyName + ";");
    deleteStatement = connection
            .prepareStatement("DELETE FROM " + tableName + " WHERE " + primaryKeyName + ";");
    existsStatement = connection
            .prepareStatement("SELECT COUNT(*) FROM " + tableName + " WHERE " + primaryKeyName + ";");
  }

  public int create(T toCreate) throws SQLException {
    try {
      List<ColumnHelper> columns = tableHelper.getColumns().stream()
              .filter(columnHelper -> !columnHelper.isAutoGenerated()).collect(Collectors.toList());
      for (int i = 0; i < columns.size(); i++) {
        Field field = columns.get(i).getField();
        createStatement.setObject(i + 1, field.get(toCreate));
      }
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }

    return createStatement.executeUpdate();
  }

  public T retrieve(Object... id) throws SQLException, IFT287Exception {
    for (int i = 0; i < id.length; i++) {
      retrieveStatement.setObject(i + 1, id[i]);
    }

    ResultSet result = retrieveStatement.executeQuery();
    if (!result.next()) {
      throw new IFT287Exception("Entity not found");
    }

    return instantiateEntity(result);
  }

  public List<T> retrieveAll() throws SQLException, IFT287Exception {
    ResultSet results = retrieveAllStatement.executeQuery();

    List<T> entities = new LinkedList<>();
    while (results.next()) {
      entities.add(instantiateEntity(results));
    }

    return entities;
  }

  protected T instantiateEntity(ResultSet resultSet) throws IFT287Exception {
    Class type = getGenericType();

    List<Constructor> constructors = Arrays.asList(type.getConstructors());
    Constructor constructor = null;
    if (constructors.size() == 1) {
      constructor = constructors.get(0);
    } else {
      for (int i = 0; i < constructors.size(); i++) {
        if (constructors.get(i).getAnnotation(Initializer.class) != null) {
          constructor = constructors.get(i);
          break;
        }
      }
    }

    if (constructor == null) {
      throw new IFT287Exception(type.getName() + " should have only one constructor or a constructor with the \"Initializer\" annotation.");
    }

    List<Object> params = new ArrayList<>();
    Class[] paramTypes = constructor.getParameterTypes();
    for (int i = 0; i < constructor.getParameterCount(); i++) {
      try {
        if (paramTypes[i].equals(Integer.class) || paramTypes[i].equals(int.class)) {
          params.add(resultSet.getInt(i + 1));
        } else if (paramTypes[i].equals(Boolean.class) || paramTypes[i].equals(boolean.class)) {
          params.add(resultSet.getBoolean(i + 1));
        } else if (paramTypes[i].equals(String.class)) {
          params.add(resultSet.getString(i + 1));
        } else if (paramTypes[i].equals(Date.class)) {
          params.add(resultSet.getDate(i + 1));
        } else {
          throw new IFT287Exception("Unsupported type in " + type.getName() + " initializer.");
        }
      } catch (SQLException e) {
        throw new IFT287Exception("Wrong parameter type.");
      }
    }

    T instance = null;
    try {
      instance = (T) constructor.newInstance(params.toArray());
    } catch (InstantiationException e) {
      throw new IFT287Exception("Cannot instantiate " + type.getName());
    } catch (IllegalAccessException e) {
      throw new IFT287Exception(type.getName() + " should have a public initializer.");
    } catch (InvocationTargetException e) {
      System.out.println(e.getMessage());
    }

    return instance;
  }

  public int update(T toUpdate) throws SQLException {
    try {
      List<ColumnHelper> columns = tableHelper.getColumns().stream()
              .filter(columnHelper -> !columnHelper.isPrimary()).collect(Collectors.toList());
      for (int i = 0; i < columns.size(); i++) {
        Field field = columns.get(i).getField();
        updateStatement.setObject(i + 1, field.get(toUpdate));
      }

      List<ColumnHelper> primaryKey = tableHelper.getPrimaryKey();
      for (int i = 0; i < primaryKey.size(); i++) {
        updateStatement.setObject(columns.size() + i + 1, primaryKey.get(i).getField().get(toUpdate));
      }
    } catch (IllegalAccessException e) {
      e.printStackTrace();
    }

    return updateStatement.executeUpdate();
  }

  public int delete(Object... id) throws SQLException {
    for (int i = 0; i < id.length; i++) {
      deleteStatement.setObject(i + 1, id[i]);
    }
    return deleteStatement.executeUpdate();
  }

  public boolean exists(Object... id) throws SQLException {
    for (int i = 0; i < id.length; i++) {
      existsStatement.setObject(i + 1, id[i]);
    }
    ResultSet result = existsStatement.executeQuery();
    result.next();
    return result.getInt(1) > 0;
  }
}
